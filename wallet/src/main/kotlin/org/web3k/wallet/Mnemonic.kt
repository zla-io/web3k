package org.web3k.wallet

import org.bouncycastle.crypto.digests.SHA512Digest
import org.bouncycastle.crypto.generators.PKCS5S2ParametersGenerator
import org.bouncycastle.crypto.params.KeyParameter
import org.web3k.common.sha256
import java.util.*
import kotlin.experimental.and

//
// Provides utility methods to generate random mnemonics and also generate seeds from mnemonics.
//
// See https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki
// for generating deterministic keys
//

/**
 * The mnemonic must encode entropy in a multiple of 32 bits. With more entropy security is
 * improved but the sentence length increases. We refer to the initial entropy length as ENT.
 * The allowed size of ENT is 128-256 bits.
 *
 * <h3>Mnemonic generation algorithm</h3>
 * Given a randomly generated initial entropy of size ENT, first a checksum is generated by
 * taking the first `ENT / 32` bits of its SHA256 hash. This checksum is appended to
 * the end of the initial entropy. Next, these concatenated bits are split into groups of
 * 11 bits, each encoding a number from 0-2047, serving as an index into a wordlist. Finally,
 * we convert these numbers into words and use the joined words as a mnemonic sentence.
 *
 * @param initialEntropy The initial entropy to generate mnemonic from
 * @param words
 * @return The generated mnemonic
 * @throws IllegalArgumentException If the given entropy is invalid
 * @throws IllegalStateException If the word list has not been loaded
 */
@JvmOverloads
fun generateMnemonic(initialEntropy: ByteArray, words: List<String> = ENGLISH_WORD_LIST): String {
    val ent = initialEntropy.size * 8
    require(ent in 128..256 && ent % 32 == 0) {
        "The allowed size of ENT is 128-256 bits of " + "multiples of 32"
    }

    val checksumLength = ent / 32

    val checksum = calculateChecksum(initialEntropy)
    val bits = convertToBits(initialEntropy, checksum)

    val iterations = (ent + checksumLength) / 11

    return (0 until iterations)
            .joinToString(separator = " ") { i ->
                val index = toInt(nextElevenBits(bits, i))
                words[index]
            }
}

/**
 * To create a binary seed from the mnemonic, we use the PBKDF2 function with a
 * mnemonic sentence (in UTF-8 NFKD) used as the password and the string "mnemonic"
 * + passphrase (again in UTF-8 NFKD) used as the salt. The iteration count is set
 * to 2048 and HMAC-SHA512 is used as the pseudo-random function. The length of the
 * derived key is 512 bits (= 64 bytes).
 *
 * @param mnemonic The input mnemonic which should be 128-160 bits in length containing only valid words
 * @param passphrase The passphrase which will be used as part of salt for PBKDF2 function
 * @return Byte array representation of the generated seed
 */
fun generateSeed(mnemonic: String, passphrase: String = ""): ByteArray {
    @Suppress("NAME_SHADOWING") // By shadowing, no possible mistake after cleaning
    val mnemonic = mnemonic.trim()
    require(mnemonic.isNotEmpty()) {
        "Mnemonic is required to generate a seed"
    }

    val salt = String.format("mnemonic%s", passphrase)
    val gen = PKCS5S2ParametersGenerator(SHA512Digest())
    gen.init(mnemonic.toByteArray(), salt.toByteArray(), SEED_ITERATIONS)

    return (gen.generateDerivedParameters(SEED_KEY_SIZE) as KeyParameter).key
}

private const val SEED_ITERATIONS = 2048
private const val SEED_KEY_SIZE = 512

/**
 * Allowing to automatically-load English word list for [generateMnemonic]
 * (not working for Android, should be stored inside assets/resources).
 */
private val ENGLISH_WORD_LIST: List<String> by lazy {
    Thread.currentThread().contextClassLoader
            .getResourceAsStream("en-mnemonic-word-list.txt")
            .bufferedReader()
            .readLines()
}

private fun nextElevenBits(bits: BooleanArray, i: Int): BooleanArray {
    val from = i * 11
    val to = from + 11
    return Arrays.copyOfRange(bits, from, to)
}

private fun convertToBits(initialEntropy: ByteArray, checksum: Byte): BooleanArray {
    val ent = initialEntropy.size * 8
    val checksumLength = ent / 32
    val totalLength = ent + checksumLength
    val bits = BooleanArray(totalLength)

    for (i in initialEntropy.indices) {
        for (j in 0..7) {
            val b = initialEntropy[i]
            bits[8 * i + j] = toBit(b, j)
        }
    }

    for (i in 0 until checksumLength) {
        bits[ent + i] = toBit(checksum, i)
    }

    return bits
}

private fun toBit(value: Byte, index: Int): Boolean =
        (value.toInt() ushr (7 - index) and 1) > 0

private fun toInt(bits: BooleanArray): Int {
    var value = 0
    for (i in bits.indices) {
        val isSet = bits[i]
        if (isSet) {
            value += 1 shl bits.size - i - 1
        }
    }

    return value
}

private fun calculateChecksum(initialEntropy: ByteArray): Byte {
    val ent = initialEntropy.size * 8
    val mask = (0xff shl 8 - ent / 32).toByte()
    val bytes = initialEntropy.sha256()

    return bytes[0] and mask
}
